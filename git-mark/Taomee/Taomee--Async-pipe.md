# Async管道相关

## 管道创建调用-->pipe_create的实质就是 对一个int [2]数组

### pipe_create的实质就是 把两个fd放到一个int [2]的数组中,然后调用pipe()函数

``` c++
pipe()函数说明
管道是一种把两个进程之间的标准输入和标准输出连接起来的机制，从而提供一种让多个进程间通信的方法，当进程创建管道时，每次都需要提供两个文件描述符来操作管道。
#include<unistd.h>
int pipe(int filedes[2]);
返回值：成功，返回0，否则返回-1。参数数组包含pipe使用的两个文件的描述符。fd[0]:读管道，fd[1]:写管道。
必须在fork()中调用pipe()，否则子进程不会继承文件描述符。两个进程不共享祖先进程，就不能使用pipe。但是可以使用有名管道。
```

### 当pipe()成功后,设置读和写为O_NONBLOCK,代表设置I/O非阻塞,当无数据可以读取的时候或者是写操作发生阻塞的时候,此时返回-1,通过调用fcntl()函数设置文件描述符的控制,同时,通过设置F_SETFD,代表close-on-exec标志,FD_CLOEXEC,父进程中此描述符被关闭,但fork()出来的子进程仍可使用

### 管道:
*  管道是单向的、先进先出的，它把一个进程的输出和另一个进程的输入连接在一起。
*  一个进程（写进程）在管道的尾部写入数据，另一个进程（读进程）从管道的头部读出数据。
*  数据被一个进程读出后，将被从管道中删除，其它读进程将不能再读到这些数据。
*  管道提供了简单的流控制机制，进程试图读空管道时，进程将阻塞。同样，管道已经满时，进程再试图向管道写入数据，进程将阻塞
*  管道包括无名管道和有名管道两种，前者用于父进程和子进程间的通信，后者可用于运行于同一系统中的任意两个进程间的通信。

### 无名管道: pipe()
通常先创建一个管道，再通过fork函数创建一个子进程，该子进程会继承父进程所创建的管道
*  创建管道pipe
*  读管道read
*  写管道write
*  关闭管道close

### 有名管道: mkfifo()
无名管道只能由父子进程使用；但是通过有名管道，不相关的进程也能交换数据
一旦创建了一个FIFO，就可用open打开它，一般的文件访问函数（close、read、write等）都可用于FIFO
