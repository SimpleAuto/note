# Async重载依靠组播机制实现,以及dlopen,dlsym,dlclose动态加载,关闭来实现的

## 组播:主机之间“一对一组”的通讯模式,也就是加入了同一个组的主机可以接受到此组内的所有数据,网络中的交换机和路由器只向有需求者复制并转发其所需数据,主机可以向路由器请求加入或退出某个组,网络中的路由器和交换机有选择的复制并传输数据,即只将组内数据传输给那些加入组的主机,这样既能一次将数据传输给多个有需要（加入组）的主机,又能保证不影响其他不需要（未加入组）的主机的其他通讯.

### 组播的工作原理:组播是一种允许一个或多个发送者（组播源）发送单一的数据包到多个接收者（一次的,同时的）的网络技术,组播源把数据包发送到特定组播组,而只有属于该组播组的地址才能接收到数据包,组播可以大大的节省网络带宽,因为无论有多少个目标地址,在整个网络的任何一条链路上只传送单一的数据包.

### 组播的优点:组播技术有效地解决了单点发送,多点接收的问题,实现了IP网络中点到多点的高效数据传送,能够大量节约网络带宽,降低网络负载.

## 重载的实现:通过bench.conf配置的addr_mcast_ip,addr_mcast_port组播的ip和端口,然后发送给属于该组播组的接收方,收到组播包后,先调用dlclose把动态加载的链接库关闭,然后在通过dlopen加载组播的数据包中的数据即新的动态链接库,然后调用dlsym进行加载句柄符号地址,完成重载

### 由于debian5之前都是可以直接加载组播包进行处理,而且每一个应用程序会加载自己的so文件,当需要关闭的时候,仅仅会关闭自己的链接库,所以不需要重命名so就可以实现重载,但debian7发生了变化,操作系统对此进行了优化,当多个进程加载同一份so时,不会各自加载一次,而是只加载一次,之后的都指向同一个地址,而且debian7某一个进程无法关闭共享的so,这样dlcose会调用失败,这样,重载就出现了问题,为了解决这个问题,现在的策略是将so重新命名,使进程重新加载一份新的so,在通过dlsym重新绑定函数地址,这样就完成了某种意义上的重载,只是原来的动态库文件并没有被关闭,但是随着重载次数的增加,进程的堆栈空间会变小,这样当进程需要的资源达到一定量的时候,4G的空间就不够用了,就会导致操作系统挂掉,造成非常大的影响,目前,项目是每周四会重启一次服务器,所以这种问题基本不会出现,如果不重启服务器,就得重新想办法了.
