#条款01:视C++作为一个语言联邦
##核心:包含了C语言的特性，面对对象，包含模板，STL库等高效开发
##示例文件:无
##C++高效编程守则视状况而变化

#条款02:尽量以const,enum,inline替换#define
##核心:尽量使用编译器来替代预处理器的工作
##原因:宏定义的变量不会加载到全局的符号表中
##示例文件:无
##对于单纯变量,最好以const对象或者enum替换#define;对于形似函数的宏,最好改用inline函数替换#define

#条款03:尽量使用const
##核心:使用const修饰的变量或者指针会经由编辑器加上限制,满足需求
##原因:const提供了很强的控制功能
##示例文件:test/test.cpp Tools_03
##const可以检测部分语法错误,const可被施加于任何作用域内的对象,函数参数,函数返回类型,成员函数本体;当const和non-const有着等价实现的情况时,可以参考Tools_03,将const强制转换为non-const是一种不错的选择,尽管看起来不好看,但避免了代码重复问题

#条款04:确定对象被使用前已经被初始化
##核心:手工初始化内执行non-member对象,使用成员初值列对付对象的所有成分
##原因:读取未初始化的值会导致不明确的行为
##示例文件:无
##为内置型对象进行手工初始化;构造函数最好使用成员初值列;初值列列出的成员变量,其排列次序应该和声明次序相同;避免跨编译单元之初始化次序情况使用local static对象替换non-locl static对象

#条款05:了解C++默默编写并调用哪些函数
##核心:Class类对象默认实现了6个函数,缺省构造,拷贝构造,析构,赋值运算符重载,&取址运算符,const &取址运算符
##原因:编译器自动生成
##示例文件:无
##编译器可以暗自为class创建default构造函数,copy构造函数,copy assignment操作符,析构函数

#条款06:若不想使用编译器自动生成的函数,就该明确拒绝
##核心:使用class中的private属性,并且只声明函数,可以不用具体的实现
##原因:条款05,编译器会默认生成6个函数,如果不提供实现,产生调用会调用编译器提供的版本,如果想友元或者外部调用,声明为private类型即可
##示例文件:无
##为驳回编译器自动提供的机能,可将相应的成员函数声明为private并且不予实现,或者是在base class中声明为private,然后派生类使用private继承base class即可

#条款07:为多态基类声明Virtual析构函数
##核心:只有当class内含至少一个virtual函数才为他声明virtual析构函数,析构函数的运作方式是:最深层派生的class其析构函数最先被调用,然后是每一个base class析构函数被调用
##原因:继承的非虚析构将会导致基类会被free,而派生类不会被free,产生内存泄漏等问题
##示例文件:无
##带有多态性质的base class应该声明一个virtual析构函数,如果class带有任何virtual函数,它就该有virtual析构函数;如果不是为了继承或者多态使用,就不该有virtual析构函数
